{"version":3,"sources":["../../../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/index.tsx","components/common/input.tsx","components/panel.tsx","context/peers.tsx","context/id.tsx","components/navbar.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Symbol","_catch","body","recover","result","useIpfsHook","args","useState","ipfs","setIpfs","error","setError","useEffect","stopIpfs","startIpfs","console","msg","window","e","Context","createContext","IpfsProvider","children","err","value","useIpfs","useContext","Input","fields","onSubmit","submit","length","initArr","i","push","val","setVal","uuid","label","preventDefault","Array","from","map","_","index","TextField","key","placeholder","isArray","onChange","newArr","currentTarget","Button","type","variant","encoder","TextEncoder","decoder","TextDecoder","Panel","enqueueSnackbar","useSnackbar","fieldId","id","setId","peers","setPeers","files","setFiles","content","setContent","file","setFile","open","setOpen","updateFiles","useCallback","a","ls","name","cid","toString","then","peersTimer","setInterval","isOnline","swarm","clearInterval","readFile","addr","cat","decode","message","Grid","container","direction","item","TableContainer","component","Paper","Table","size","aria-label","TableBody","TableRow","TableCell","scope","noValidate","autoComplete","event","write","create","style","display","htmlFor","pubsub","subscribe","data","publish","encode","Dialog","onClose","DialogContent","context","SignalIcon","number","SignalCellularConnectedNoInternet0Bar","SignalCellular0Bar","SignalCellular1Bar","SignalCellular2Bar","SignalCellular3Bar","SignalCellular4Bar","NavBar","anchorEl","setAnchorEl","randStr","menuId","peerNum","setPeerNum","Peers","closeMenu","flexGrow","AppBar","position","Toolbar","Typography","noWrap","IconButton","Badge","badgeContent","Group","edge","aria-controls","aria-haspopup","onClick","Menu","getContentAnchorEl","anchorOrigin","vertical","horizontal","transformOrigin","keepMounted","MenuItem","start","stop","useStyles","makeStyles","theme","root","backgroundColor","palette","background","paper","App","styles","ipfsErr","reset","job","prs","Provider","className","spacing","alignItems","Boolean","location","hostname","match","ReactDOM","render","StrictMode","CssBaseline","maxSnack","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch"],"mappings":"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","file":"static/js/main.24049538.chunk.js","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import React, {\n  FC,\n  useContext,\n  createContext,\n  useState,\n  useEffect,\n} from 'react'\nimport { create } from 'ipfs'\n\ntype Ipfs = any\n\ndeclare global {\n  interface Window {\n    ipfs?: Ipfs\n  }\n}\n\nconst useIpfsHook = (\n  ...args: Parameters<typeof create>\n): [Ipfs | null, Error | null] => {\n  const [ipfs, setIpfs] = useState<Ipfs | null>(null)\n  const [error, setError] = useState<Error | null>(null)\n\n  useEffect(() => {\n    async function stopIpfs() {\n      setIpfs(null)\n      setError(null)\n    }\n    async function startIpfs() {\n      try {\n        const msg = `IPFS Created`\n        console.time(msg)\n        setIpfs(\n          window.ipfs ||\n            (await create(...args).then(async (ipfs) => {\n              window.ipfs = ipfs\n              return ipfs\n            }))\n        )\n        console.timeEnd(msg)\n        setError(null)\n      } catch (e) {\n        console.error('IPFS creation error:', e)\n        setIpfs(null)\n        setError(e)\n      }\n    }\n    stopIpfs().then(() => startIpfs())\n\n    return () => {\n      stopIpfs()\n    }\n  }, args)\n\n  return [ipfs, error]\n}\n\nconst Context = createContext<[Ipfs | null, Error | null]>([null, null])\n\ntype Props = {\n  args?: Parameters<typeof useIpfsHook>[0]\n}\nexport const IpfsProvider: FC<Props> = ({ children, args }) => {\n  const [ipfs, err] = useIpfsHook(args)\n  return <Context.Provider value={[ipfs, err]}>{children}</Context.Provider>\n}\n\nexport const useIpfs = () => {\n  const con = useContext(Context)\n  return con\n}\n","import React, { FC, useState } from 'react'\nimport { TextField, Button } from '@material-ui/core'\nimport { v4 as uuid } from 'uuid'\n\ntype Props = {\n  onSubmit: (val: string[]) => void\n  submit?: string\n  fields?: string[] | number\n}\n\nexport const Input: FC<Props> = ({\n  fields = 1,\n  onSubmit,\n  submit = `submit`,\n}) => {\n  const length = typeof fields === 'number' ? fields : fields.length\n  const [val, setVal] = useState<string[]>(() => {\n    const initArr = []\n    for (let i = 0; i < length; ++i) initArr.push(``)\n    return initArr\n  })\n  const [label] = useState<string>(uuid())\n  return (\n    <form\n      onSubmit={e => {\n        e.preventDefault()\n        onSubmit(val)\n      }}\n    >\n      {Array.from(new Array(length)).map((_, index) => (\n        <TextField\n          key={`${label}-${index}`}\n          placeholder={Array.isArray(fields) ? fields[index] : ``}\n          onChange={e => {\n            const newArr = Array.from(val)\n            newArr[index] = e.currentTarget.value\n            setVal(newArr)\n          }}\n        />\n      ))}\n      <Button type=\"submit\" variant=\"contained\">\n        {submit}\n      </Button>\n    </form>\n  )\n}\n","import React, { FC, useCallback, useState, useEffect } from 'react'\nimport { v1 as uuid } from 'uuid'\nimport { useIpfs } from '@onichandame/react-ipfs-hook'\nimport { useSnackbar } from 'notistack'\nimport {\n  Dialog,\n  DialogContent,\n  Paper,\n  Button,\n  Grid,\n  TableContainer,\n  Table,\n  TableBody,\n  TableRow,\n  TableCell,\n} from '@material-ui/core'\n\nimport { Input } from './common'\n\ntype Ipfs = ReturnType<typeof useIpfs>[0]\n\ntype Props = {\n  ipfs: Ipfs | null\n}\n\nconst encoder = new TextEncoder()\nconst decoder = new TextDecoder()\n\nexport const Panel: FC<Props> = ({ ipfs }) => {\n  const { enqueueSnackbar } = useSnackbar()\n  const fieldId = `file-${uuid()}`\n  const [id, setId] = useState<string>(``)\n  const [peers, setPeers] = useState<number>(0)\n  const [files, setFiles] = useState<{ name: string; cid: string }[]>([])\n  const [content, setContent] = useState<string>(``)\n  const [file, setFile] = useState<File | null>(null)\n  const [open, setOpen] = useState<boolean>(false)\n  const updateFiles = useCallback(async () => {\n    if (ipfs) {\n      const result = []\n      for await (const file of ipfs.files.ls(`/`))\n        result.push({ name: file.name, cid: file.cid.toString() })\n      setFiles(result)\n    }\n  }, [ipfs])\n  useEffect(() => {\n    if (ipfs && ipfs.id) {\n      ipfs.id().then((id: any) => {\n        setId(id.id)\n        updateFiles()\n      })\n      const peersTimer = setInterval(async () => {\n        if (ipfs && ipfs.isOnline()) setPeers((await ipfs.swarm.peers()).length)\n      }, 1000)\n      return () => {\n        clearInterval(peersTimer)\n      }\n    }\n  }, [ipfs, updateFiles])\n  const readFile = useCallback(\n    async (addr: string) => {\n      if (ipfs && addr) {\n        try {\n          let result = ``\n          for await (const file of ipfs.cat(addr)) {\n            result = decoder.decode(file)\n            break // Read only one file\n          }\n          setContent(result)\n        } catch (e) {\n          setContent(e.message)\n        }\n        setOpen(true)\n      }\n    },\n    [ipfs]\n  )\n  return (\n    <>\n      <Grid container direction=\"column\">\n        <Grid item>\n          <TableContainer component={Paper}>\n            <Table size=\"small\" aria-label=\"node info\">\n              <TableBody>\n                <TableRow>\n                  <TableCell component=\"th\" scope=\"row\">\n                    ID\n                  </TableCell>\n                  <TableCell>{id}</TableCell>\n                </TableRow>\n                <TableRow>\n                  <TableCell component=\"th\" scope=\"row\">\n                    Peers\n                  </TableCell>\n                  <TableCell>{peers}</TableCell>\n                </TableRow>\n                <TableRow>\n                  <TableCell component=\"th\" scope=\"row\">\n                    Publish\n                  </TableCell>\n                  <TableCell>\n                    <form\n                      noValidate\n                      autoComplete=\"off\"\n                      onSubmit={event => {\n                        event.preventDefault()\n                        if (ipfs && file)\n                          ipfs.files\n                            .write(`/${file.name}`, file, { create: true })\n                            .then(updateFiles)\n                      }}\n                    >\n                      <input\n                        id={fieldId}\n                        style={{ display: 'none' }}\n                        type=\"file\"\n                        onChange={e => {\n                          e.preventDefault()\n                          if (\n                            e.currentTarget.files &&\n                            e.currentTarget.files.length\n                          )\n                            setFile(e.currentTarget.files[0])\n                        }}\n                      />\n                      <label htmlFor={fieldId}>\n                        <Button variant=\"text\" component=\"span\">\n                          {file?.name || `choose a file`}\n                        </Button>\n                      </label>\n                      <Button type=\"submit\" variant=\"contained\">\n                        submit\n                      </Button>\n                    </form>\n                  </TableCell>\n                </TableRow>\n                <TableRow>\n                  <TableCell component=\"th\" scope=\"row\">\n                    Read\n                  </TableCell>\n                  <TableCell>\n                    <Input onSubmit={val => readFile(val[0])} />\n                  </TableCell>\n                </TableRow>\n                <TableRow>\n                  <TableCell component=\"th\" scope=\"row\">\n                    Subscribe\n                  </TableCell>\n                  <TableCell>\n                    <Input\n                      fields={[`topic`]}\n                      submit=\"subscribe\"\n                      onSubmit={async val => {\n                        if (ipfs) {\n                          await ipfs.pubsub.subscribe(val[0], (msg: any) => {\n                            enqueueSnackbar(\n                              `received message ${decoder.decode(msg.data)}`\n                            )\n                          })\n                          enqueueSnackbar(`subscribed to ${val}`)\n                        }\n                      }}\n                    />\n                  </TableCell>\n                </TableRow>\n                <TableRow>\n                  <TableCell component=\"th\" scope=\"row\">\n                    Publish\n                  </TableCell>\n                  <TableCell>\n                    <Input\n                      submit=\"publish\"\n                      fields={[`topic`, `message`]}\n                      onSubmit={async val => {\n                        if (ipfs) {\n                          await ipfs.pubsub.publish(\n                            val[0],\n                            encoder.encode(val[1])\n                          )\n                          enqueueSnackbar(\n                            `published ${val[1]} to topic ${val[0]}`\n                          )\n                        }\n                      }}\n                    />\n                  </TableCell>\n                </TableRow>\n                <TableRow>\n                  <TableCell component=\"th\" scope=\"row\">\n                    Files\n                  </TableCell>\n                  <TableCell>\n                    <TableContainer>\n                      <Table size=\"small\" aria-label={`file list ${uuid()}`}>\n                        <TableBody>\n                          {files.map(file => (\n                            <TableRow key={`file-${uuid()}`}>\n                              <TableCell>{file.name}</TableCell>\n                              <TableCell>{file.cid}</TableCell>\n                            </TableRow>\n                          ))}\n                        </TableBody>\n                      </Table>\n                    </TableContainer>\n                  </TableCell>\n                </TableRow>\n              </TableBody>\n            </Table>\n          </TableContainer>\n        </Grid>\n      </Grid>\n      <Dialog open={open} onClose={() => setOpen(false)}>\n        <DialogContent>{content}</DialogContent>\n      </Dialog>\n    </>\n  )\n}\n","import { createContext } from 'react'\n\ntype Peer = {\n  addr: any\n  peer: string\n  // only if verbose: true\n  latency?: string\n  muxer: string\n  // only if verbose: true\n  streams?: string[]\n  direction: number\n}\n\nconst context = createContext<Peer[]>([])\n\nexport { context as Peers }\n","import { createContext } from 'react'\n\nconst context = createContext<string>(``)\n\nexport { context as Id }\n","import React, { useEffect, useContext, MouseEvent, FC, useState } from 'react'\nimport { v4 as randStr } from 'uuid'\nimport {\n  Group,\n  SignalCellular0Bar,\n  SignalCellular1Bar,\n  SignalCellular2Bar,\n  SignalCellular3Bar,\n  SignalCellular4Bar,\n  SignalCellularConnectedNoInternet0Bar,\n} from '@material-ui/icons'\nimport {\n  Menu,\n  Badge,\n  MenuItem,\n  IconButton,\n  AppBar,\n  Toolbar,\n  Typography,\n} from '@material-ui/core'\nimport { useIpfs } from '@onichandame/react-ipfs-hook'\n\nimport { Peers } from '../context'\n\nconst SignalIcon: FC<{ number: number }> = ({ number }) => {\n  return number <= 0 ? (\n    <SignalCellularConnectedNoInternet0Bar />\n  ) : number < 10 ? (\n    <SignalCellular0Bar />\n  ) : number < 64 ? (\n    <SignalCellular1Bar />\n  ) : number < 128 ? (\n    <SignalCellular2Bar />\n  ) : number < 256 ? (\n    <SignalCellular3Bar />\n  ) : (\n    <SignalCellular4Bar />\n  )\n}\n\nexport const NavBar: FC = () => {\n  const [ipfs] = useIpfs()\n  const [anchorEl, setAnchorEl] = useState<HTMLElement | null>(null)\n  const [menuId] = useState(randStr())\n  const [peerNum, setPeerNum] = useState(0)\n\n  const peers = useContext(Peers)\n\n  useEffect(() => {\n    if (peers.length !== peerNum) setPeerNum(peers.length)\n  }, [peers, peerNum])\n\n  const openMenu = (e: MouseEvent<HTMLElement>) => {\n    setAnchorEl(e.currentTarget)\n  }\n  const closeMenu = () => {\n    setAnchorEl(null)\n  }\n\n  return (\n    <div style={{ flexGrow: 1 }}>\n      <AppBar position=\"static\">\n        <Toolbar>\n          <Typography variant=\"h6\" noWrap>\n            IPFS\n          </Typography>\n          <div style={{ flexGrow: 1 }} />\n          <IconButton>\n            <Badge badgeContent={peerNum}>\n              <Group />\n            </Badge>\n          </IconButton>\n          <IconButton\n            edge=\"end\"\n            aria-label=\"ipfs node\"\n            aria-controls={menuId}\n            aria-haspopup=\"true\"\n            onClick={openMenu}\n          >\n            <SignalIcon number={peerNum} />\n          </IconButton>\n        </Toolbar>\n      </AppBar>\n      <Menu\n        anchorEl={anchorEl}\n        getContentAnchorEl={null}\n        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}\n        transformOrigin={{ vertical: 'top', horizontal: 'right' }}\n        id={menuId}\n        keepMounted\n        open={!!anchorEl}\n        onClose={closeMenu}\n      >\n        <MenuItem\n          onClick={() => {\n            closeMenu()\n            ipfs && !ipfs.isOnline() && ipfs.start()\n          }}\n        >\n          Start\n        </MenuItem>\n        <MenuItem\n          onClick={() => {\n            closeMenu()\n            ipfs && ipfs.isOnline() && ipfs.stop()\n          }}\n        >\n          Stop\n        </MenuItem>\n      </Menu>\n    </div>\n  )\n}\n","import React, { ContextType, useEffect, useState } from 'react'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { useIpfs } from '@onichandame/react-ipfs-hook'\nimport { Grid } from '@material-ui/core'\n\nimport { Panel, NavBar } from './components'\nimport { Peers, Id } from './context'\n\nconst useStyles = makeStyles(theme => ({\n  root: {\n    flexGrow: 1,\n    backgroundColor: theme.palette.background.paper,\n  },\n}))\n\nfunction App() {\n  const styles = useStyles()\n  const [ipfs, ipfsErr] = useIpfs()\n  const [id, setId] = useState(``)\n  const [peers, setPeers] = useState<ContextType<typeof Peers>>([])\n\n  // update basic info regularly\n  useEffect(() => {\n    const reset = () => {\n      setId(``)\n      setPeers([])\n    }\n    const job = setInterval(() => {\n      if (!ipfsErr && ipfs) {\n        if (ipfs.isOnline()) {\n          ipfs.id().then(({ id }: { id: string }) => setId(id))\n          ipfs.swarm.peers().then((prs: any[]) => setPeers(prs))\n        } else {\n          reset()\n        }\n      } else {\n        reset()\n      }\n    }, 1000)\n    return () => clearInterval(job)\n  }, [ipfs, ipfsErr])\n  return (\n    <Peers.Provider value={peers}>\n      <Id.Provider value={id}>\n        <div className={styles.root}>\n          <NavBar />\n          <Grid container spacing={0} direction={'column'} alignItems=\"center\">\n            <Grid item>\n              {(ipfsErr && ipfsErr.message) || ipfs ? (\n                <Panel ipfs={ipfs} />\n              ) : (\n                `loading`\n              )}\n            </Grid>\n          </Grid>\n        </div>\n      </Id.Provider>\n    </Peers.Provider>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { CssBaseline } from '@material-ui/core'\nimport { SnackbarProvider } from 'notistack'\nimport { IpfsProvider } from '@onichandame/react-ipfs-hook'\n\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(\n  <React.StrictMode>\n    <>\n      <CssBaseline />\n      <SnackbarProvider maxSnack={3}>\n        <IpfsProvider>\n          <App />\n        </IpfsProvider>\n      </SnackbarProvider>\n    </>\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}